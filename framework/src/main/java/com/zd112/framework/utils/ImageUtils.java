package com.zd112.framework.utils;import android.annotation.SuppressLint;import android.app.Activity;import android.content.ContentResolver;import android.content.ContentUris;import android.content.Context;import android.content.Intent;import android.database.Cursor;import android.graphics.Bitmap;import android.graphics.BitmapFactory;import android.graphics.Color;import android.graphics.Matrix;import android.media.ThumbnailUtils;import android.net.Uri;import android.os.AsyncTask;import android.os.Build;import android.os.Environment;import android.os.Handler;import android.os.Message;import android.provider.DocumentsContract;import android.provider.MediaStore;import android.support.annotation.RequiresApi;import android.text.TextUtils;import android.util.Base64;import android.view.View;import android.widget.ImageView;import com.zd112.framework.BuildConfig;import com.zd112.framework.view.qrcode.codec.QRCodeEncoder;import com.zd112.framework.view.qrcode.core.QRCodeUtil;import java.io.BufferedInputStream;import java.io.BufferedOutputStream;import java.io.ByteArrayInputStream;import java.io.ByteArrayOutputStream;import java.io.File;import java.io.FileNotFoundException;import java.io.FileOutputStream;import java.io.IOException;import java.io.InputStream;import java.net.MalformedURLException;import java.net.URL;import java.util.ArrayList;/** * 图像相关工具类 */public class ImageUtils extends Thread implements Runnable {    public static final int LEFT = 0;    public static final int RIGHT = 1;    public static final int TOP = 3;    public static final int BOTTOM = 4;    public static String bitNametime;    private String mUrl;    private Handler mHandler;    public static final int SUCCESS = 1;    public static final int FALSE = -1;    private static final int IO_BUFFER_SIZE = 2 * 1024;    public ImageUtils(String url, Handler handler) {        this.mUrl = url;        this.mHandler = handler;    }    @Override    public void run() {        super.run();        Bitmap bitmap = null;        if (!TextUtils.isEmpty(mUrl)) {            bitmap = getBitmap(mUrl);        }        Message message = new Message();        if (bitmap != null) {            message.what = SUCCESS;            message.obj = bitmap;        } else {            message.what = FALSE;        }        mHandler.sendMessage(message);    }    public static Bitmap getBitmap(String url) {        Bitmap bitmap;        InputStream in = null;        BufferedOutputStream out = null;        try {            in = new BufferedInputStream(new URL(url).openStream(), IO_BUFFER_SIZE);            final ByteArrayOutputStream dataStream = new ByteArrayOutputStream();            out = new BufferedOutputStream(dataStream, IO_BUFFER_SIZE);            copy(in, out);            out.flush();            byte[] data = dataStream.toByteArray();            bitmap = BitmapFactory.decodeByteArray(data, 0, data.length);            return bitmap;        } catch (IOException e) {            e.printStackTrace();            return null;        } finally {            if (in != null) {                try {                    in.close();                } catch (IOException e) {                    e.printStackTrace();                }            }            if (out != null) {                try {                    out.close();                } catch (IOException e) {                    e.printStackTrace();                }            }        }    }    public static void copy(InputStream in, BufferedOutputStream out) throws IOException {        byte[] buff = new byte[1024];        int end = -1;        while ((end = in.read(buff)) != -1) {            out.write(buff, 0, end);        }    }    /**     * 调用系统拍照     *     * @param activity     */    public static void takeCamera(Activity activity) {        Intent intent = new Intent(Intent.ACTION_GET_CONTENT);        intent.addCategory(Intent.CATEGORY_OPENABLE);        intent.setType("image/*");        activity.startActivityForResult(Intent.createChooser(intent, "选择图片"), 1);    }    /**     * 调用系统相册     *     * @param activity     */    public static void takePhoto(Activity activity) {        Intent intent = new Intent(MediaStore.ACTION_IMAGE_CAPTURE);        activity.startActivityForResult(intent, 2);    }    /**     * 调用系统裁剪     *     * @param aty     * @param uri     * @param imagePath     */    public static void takeCut(Activity aty, Uri uri, String imagePath) {        File f = new File(imagePath);        if (!f.exists()) {            File parentFile = f.getParentFile();            if (!parentFile.exists()) {                parentFile.mkdirs();            }            try {                f.createNewFile();            } catch (IOException e) {                e.printStackTrace();            }        }        Intent intent = new Intent("com.android.camera.action.CROP");        intent.setDataAndType(uri, "image/*");        // crop为true是设置在开启的intent中设置显示的view可以剪裁        intent.putExtra("crop", "true");        // aspectX aspectY 是宽高的比例        intent.putExtra("aspectX", 1);        intent.putExtra("aspectY", 1);        // outputX,outputY 是剪裁图片的宽高        intent.putExtra("outputX", 300);        intent.putExtra("outputY", 300);        intent.putExtra("return-data", true);        intent.putExtra("noFaceDetection", true);        intent.putExtra("output", Uri.fromFile(new File(imagePath)));// 保存到原文件        intent.putExtra("outputFormat", "JPEG");// 返回格式        aty.startActivityForResult(intent, 3);    }    /**     * 在activityOnResult中拿到图片     *     * @param data    在onActivityResult中拿到的Intent     * @param context     * @return     */    public static Bitmap getDataOnResult(Intent data, Context context) {        Bitmap bitmap = null;        Uri uri = data.getData();        ContentResolver cr = context.getContentResolver();        try {            bitmap = BitmapFactory.decodeStream(cr.openInputStream(uri));        } catch (FileNotFoundException e) {            e.printStackTrace();        }        return bitmap;    }    //图像数据大小相关    /**     * 图像数据大小压缩到指定大小     *     * @param image     原始图像     * @param fileCount 压缩到的图像数据大小     * @return     */    public static Bitmap compressBitmap(Bitmap image, int fileCount) {        ByteArrayOutputStream baos = new ByteArrayOutputStream();        image.compress(Bitmap.CompressFormat.JPEG, 100, baos);//质量压缩方法，这里100表示不压缩，把压缩后的数据存放到baos中        int options = 100;        while (baos.toByteArray().length / 1024 > 100) {  //循环判断如果压缩后图片是否大于100kb,大于继续压缩。很傻很天真，这个toByteArray根本不能返回真的图像大小。            baos.reset();//重置baos即清空baos            image.compress(Bitmap.CompressFormat.JPEG, options, baos);//这里压缩options%，把压缩后的数据存放到baos中            options -= 10;//每次都减少10        }        ByteArrayInputStream isBm = new ByteArrayInputStream(baos.toByteArray());//把压缩后的数据baos存放到ByteArrayInputStream中        Bitmap bitmap = BitmapFactory.decodeStream(isBm, null, null);//把ByteArrayInputStream数据生成图片        return bitmap;    }    /**     * 保存图像到指定路径     *     * @param bitmap 原始图像     * @param path   保存路径     * @param name   保存名称     */    public void saveBitmap(Bitmap bitmap, String path, String name) {        File f = FileUtils.createFile(path, name);        FileOutputStream fos = null;        try {            fos = new FileOutputStream(f);        } catch (FileNotFoundException e) {            e.printStackTrace();        }        bitmap.compress(Bitmap.CompressFormat.PNG, 100, fos);        try {            fos.flush();        } catch (IOException e) {            e.printStackTrace();        }        try {            fos.close();        } catch (IOException e) {            e.printStackTrace();        }    }    /**     * 保存图像到手机图片库中     */    public static String saveBitmap2Album(Context context, Bitmap bitmap) {        //将生成的Bitmap插入到手机的图片库当中，获取到图片路径        String filePath = MediaStore.Images.Media.insertImage(context.getContentResolver(), bitmap, null, null);        //及时回收Bitmap对象，防止OOM        if (!bitmap.isRecycled()) {            bitmap.recycle();        }        //转uri之前必须判空，防止保存图片失败        if (TextUtils.isEmpty(filePath)) {            return "";        }        return getRealPathFromURI(context, Uri.parse(filePath));    }    private static String getRealPathFromURI(Context context, Uri contentUri) {        Cursor cursor = null;        try {            String[] proj = {MediaStore.Images.Media.DATA};            cursor = context.getContentResolver().query(contentUri, proj, null, null, null);            if (cursor == null) {                return "";            }            int column_index = cursor.getColumnIndexOrThrow(MediaStore.Images.Media.DATA);            cursor.moveToFirst();            return cursor.getString(column_index);        } finally {            if (cursor != null) {                cursor.close();            }        }    }    /**     * 将多幅图像合并，存储到一个文件中。     * 一般用于同时发送多张图片，网络接口中加上另一个字段，用于存储每副图像的大小，这样服务端就可以按照每副图像大小逐个取出图像，存在服务端，同时保证了图像的顺序性。     *     * @param path     * @param bitmapArrayList     * @throws Exception     */    public static void unionMultiImages(String path, String name, ArrayList<Bitmap> bitmapArrayList) throws Exception {        File file = FileUtils.createFile(path, name);        FileOutputStream fos = new FileOutputStream(file);        for (int i = 0; i < bitmapArrayList.size(); i++) {            Bitmap currentBitmap = bitmapArrayList.get(i);            currentBitmap.compress(Bitmap.CompressFormat.PNG, 100, fos);        }        fos.flush();        fos.close();    }    //图像尺寸大小相关    /**     * 从指定路径获取图片，按照指定长宽尺寸获取图片     * 原理：用流去获取图像，计算得到所需Options，然后用options加载图片。     *     * @param imagePath     * @param imageSize     * @param requestWidth     * @param requestHeight     * @return     */    public static Bitmap getBitmapFromPath(String imagePath, int imageSize, int requestWidth, int requestHeight) {        Bitmap bitmap = null;        BitmapFactory.Options options = new BitmapFactory.Options();        File file = new File(imagePath);        long size = file.length();        long multiple = size / (imageSize * 1024);        double multiSqrt = Math.sqrt(multiple);        int multiAbs = (int) Math.abs(multiSqrt);        options.inSampleSize = multiAbs;        try {            bitmap = BitmapFactory.decodeFile(imagePath, options);        } catch (OutOfMemoryError ooe) {            return null;        } catch (Exception e) {            return null;        }        //如果图片的长、宽大于指定长宽，则强制大小，并做等比缩放；否则用原图        int bitmapActualWidth = bitmap.getWidth();        int bitmapActualHeight = bitmap.getHeight();        int bitmapResultWidth = 0;        int bitmapResultHeight = 0;        //如果实际宽高有一个比要求宽高要大，则需要做等比缩放        if (bitmapActualWidth > requestWidth || bitmapActualHeight > requestHeight) {            //计算缩放比例，如果宽度缩放更大，则按照宽度等比缩放；如果高度缩放更大，则按照高度等比缩放            float widthScale = bitmapActualWidth / requestWidth;            float heightScale = bitmapActualHeight / requestHeight;            if (widthScale > heightScale) {                bitmapResultWidth = requestWidth;                bitmapResultHeight = bitmapResultWidth * bitmapActualHeight / bitmapActualWidth;            } else {                bitmapResultHeight = requestHeight;                bitmapResultWidth = bitmapResultHeight * bitmapActualWidth / bitmapActualHeight;            }            bitmap = zoomBitmap(bitmap, bitmapResultWidth, bitmapResultHeight);        }        return bitmap;    }    /**     * 等比例缩放图片到指定尺寸的长宽     *     * @param bitmap     * @param width     * @param height     * @return     */    public static Bitmap zoomBitmap(Bitmap bitmap, double width, double height) {        Bitmap zoomBitmap = null;        int w = bitmap.getWidth();        int h = bitmap.getHeight();        Matrix matrix = new Matrix();        float scaleWidht = ((float) width / w);        float scaleHeight = ((float) height / h);        matrix.postScale(scaleWidht, scaleHeight);        try {            zoomBitmap = Bitmap.createBitmap(bitmap, 0, 0, w, h, matrix, true);        } catch (Exception e) {        }        return zoomBitmap;    }    /**     * 比例缩放图片到指定尺寸的长宽-方法2     *     * @param imagePath     * @param width     * @param height     * @return     */    public Bitmap zoomBitmap(String imagePath, int width, int height) {        Bitmap bitmap = null;        BitmapFactory.Options options = new BitmapFactory.Options();        options.inJustDecodeBounds = true;        bitmap = BitmapFactory.decodeFile(imagePath, options);        options.inJustDecodeBounds = false;        int h = options.outHeight;        int w = options.outWidth;        int beWidth = w / width;        int beHeight = h / height;        int be = 1;        if (beWidth < beHeight) {            be = beWidth;        } else {            be = beHeight;        }        if (be <= 0) {            be = 1;        }        options.inSampleSize = be;        bitmap = BitmapFactory.decodeFile(imagePath, options);        bitmap = ThumbnailUtils.extractThumbnail(bitmap, width, height, ThumbnailUtils.OPTIONS_RECYCLE_INPUT);        return bitmap;    }    /**     * 从原图像上截取指定大小的图像     *     * @param bitmap 原始图像     * @param x      截取起点的x坐标     * @param y      截取起点的y坐标     * @param width  截取宽度     * @param height 截取高度     * @return     */    public static Bitmap cutBitmap(Bitmap bitmap, int x, int y, int width, int height) {        return Bitmap.createBitmap(bitmap, x, y, width, height);    }    /**     * 获取视频缩略图     *     * @param videoPath     * @param width     * @param height     * @param kind     * @return     */    public static Bitmap getVideoThumbnail(String videoPath, int width, int height, int kind) {        Bitmap bitmap = null;        bitmap = ThumbnailUtils.createVideoThumbnail(videoPath, kind);        bitmap = ThumbnailUtils.extractThumbnail(bitmap, width, height, ThumbnailUtils.OPTIONS_RECYCLE_INPUT);        return bitmap;    }    /**     * View生成Bitmap     */    public static Bitmap loadBitmapFromView(Context context, View view) {        view.setDrawingCacheEnabled(true);        view.measure(View.MeasureSpec.makeMeasureSpec(context.getResources().getDisplayMetrics().widthPixels, View.MeasureSpec.EXACTLY),                View.MeasureSpec.makeMeasureSpec(0, View.MeasureSpec.UNSPECIFIED));        view.layout(0, 0, view.getMeasuredWidth(), view.getMeasuredHeight());        view.buildDrawingCache();        Bitmap bitmap = view.getDrawingCache();        return bitmap;    }    /**     * Base64 to Bitmap     *     * @param str     * @return     */    public static Bitmap stringToBitmap(String str) {        Bitmap bitmap = null;        try {            byte[] bytes = Base64.decode(str, Base64.DEFAULT);            bitmap = BitmapFactory.decodeByteArray(bytes, 0, bytes.length);        } catch (Exception e) {            e.printStackTrace();        }        return bitmap;    }    /**     * the get url for save local add return file pathls -     *     * @param picUrl     * @return     */    private static String resultFilePath = null;    @SuppressLint("CheckResult")    public static String getUrlPicFile(Context context, final String picUrl) {        InputStream inputStream = null;        try {            URL url = new URL(picUrl);            inputStream = url.openStream();            if (inputStream != null) {                String fileName = null;                if (!TextUtils.isEmpty(picUrl) && picUrl.contains("/")) {                    fileName = picUrl.substring(picUrl.lastIndexOf("/"), picUrl.length());                }                if (picUrl.length() == 0) {                    fileName = System.currentTimeMillis() + ".jpg";                }                File file = FileUtils.writeInputStream2File(inputStream, BuildConfig.FILE_DIR, fileName);                if (file != null) {                    resultFilePath = file.getAbsolutePath();                }                inputStream.close();            }        } catch (MalformedURLException e) {            e.printStackTrace();        } catch (IOException e) {            e.printStackTrace();        }        return resultFilePath;    }    /**     * @param context     * @param icon     * @param imageView     */    public static void showQRImg(final Context context, final int icon, final String content, final ImageView imageView) {        new AsyncTask<Void, Void, Bitmap>() {            @Override            protected Bitmap doInBackground(Void... params) {                Bitmap logoBitmap = BitmapFactory.decodeResource(context.getResources(), icon);                return QRCodeEncoder.syncEncodeQRCode(content, QRCodeUtil.dp2px(context, 150), Color.BLACK, Color.WHITE, logoBitmap);            }            @Override            protected void onPostExecute(Bitmap bitmap) {                if (bitmap != null) {                    imageView.setImageBitmap(bitmap);                } else {                    ToastUtil.show(context, "生成带logo的英文二维码失败");                }            }        }.execute();    }    /**     * Method for return file path of Gallery image     *     * @param context     * @param uri     * @return path of the selected image file from gallery     */    @RequiresApi(api = Build.VERSION_CODES.KITKAT)    public static String getPath(final Context context, final Uri uri) {        // check here to KITKAT or new version        final boolean isKitKat = Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT;        // DocumentProvider        if (isKitKat && DocumentsContract.isDocumentUri(context, uri)) {            // ExternalStorageProvider            if (isExternalStorageDocument(uri)) {                final String docId = DocumentsContract.getDocumentId(uri);                final String[] split = docId.split(":");                final String type = split[0];                if ("primary".equalsIgnoreCase(type)) {                    return Environment.getExternalStorageDirectory() + "/"                            + split[1];                }            }            // DownloadsProvider            else if (isDownloadsDocument(uri)) {                final String id = DocumentsContract.getDocumentId(uri);                final Uri contentUri = ContentUris.withAppendedId(                        Uri.parse("content://downloads/public_downloads"),                        Long.valueOf(id));                return getDataColumn(context, contentUri, null, null);            }            // MediaProvider            else if (isMediaDocument(uri)) {                final String docId = DocumentsContract.getDocumentId(uri);                final String[] split = docId.split(":");                final String type = split[0];                Uri contentUri = null;                if ("image".equals(type)) {                    contentUri = MediaStore.Images.Media.EXTERNAL_CONTENT_URI;                } else if ("video".equals(type)) {                    contentUri = MediaStore.Video.Media.EXTERNAL_CONTENT_URI;                } else if ("audio".equals(type)) {                    contentUri = MediaStore.Audio.Media.EXTERNAL_CONTENT_URI;                }                final String selection = "_id=?";                final String[] selectionArgs = new String[]{split[1]};                return getDataColumn(context, contentUri, selection,                        selectionArgs);            }        }        // MediaStore (and general)        else if ("content".equalsIgnoreCase(uri.getScheme())) {            // Return the remote address            if (isGooglePhotosUri(uri)) {                return uri.getLastPathSegment();            }            return getDataColumn(context, uri, null, null);        }        // File        else if ("file".equalsIgnoreCase(uri.getScheme())) {            return uri.getPath();        }        return null;    }    /**     * Get the value of the data column for this Uri. This is useful for     * MediaStore Uris, and other file-based ContentProviders.     *     * @param context       The context.     * @param uri           The Uri to query.     * @param selection     (Optional) Filter used in the query.     * @param selectionArgs (Optional) Selection arguments used in the query.     * @return The value of the _data column, which is typically a file path.     */    public static String getDataColumn(Context context, Uri uri,                                       String selection, String[] selectionArgs) {        Cursor cursor = null;        final String column = "_data";        final String[] projection = {column};        try {            cursor = context.getContentResolver().query(uri, projection,                    selection, selectionArgs, null);            if (cursor != null && cursor.moveToFirst()) {                final int index = cursor.getColumnIndexOrThrow(column);                return cursor.getString(index);            }        } finally {            if (cursor != null) {                cursor.close();            }        }        return null;    }    /**     * @param uri The Uri to check.     * @return Whether the Uri authority is ExternalStorageProvider.     */    public static boolean isExternalStorageDocument(Uri uri) {        return "com.android.externalstorage.documents".equals(uri                .getAuthority());    }    /**     * @param uri The Uri to check.     * @return Whether the Uri authority is DownloadsProvider.     */    public static boolean isDownloadsDocument(Uri uri) {        return "com.android.providers.downloads.documents".equals(uri                .getAuthority());    }    /**     * @param uri The Uri to check.     * @return Whether the Uri authority is MediaProvider.     */    public static boolean isMediaDocument(Uri uri) {        return "com.android.providers.media.documents".equals(uri                .getAuthority());    }    /**     * @param uri The Uri to check.     * @return Whether the Uri authority is Google Photos.     */    public static boolean isGooglePhotosUri(Uri uri) {        return "com.google.android.apps.photos.content".equals(uri                .getAuthority());    }}